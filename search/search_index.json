{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Roact-Rodux is the official binding layer between Roact , a view library, and Rodux , a state management library.","title":"Home"},{"location":"api-reference/","text":"Roact Components \u00b6 StoreProvider \u00b6 StoreProvider accepts a Rodux store via the store prop and makes it available to all components rendered under it. It's possible to have multiple instances of StoreProvider in the same Roact tree, but most projects using Roact-Rodux will only have one. StoreProvider is generally at the top of the tree: Roact . createElement ( RoactRodux . StoreProvider , { store = someStore , }, { -- Any components created by `App` will be able to connect to someStore by -- using Roact-Rodux's `connect` method. App = Roact . createElement ( App ), }) Warning Due to limitations of Roact, StoreProvider can only have zero or one children. This requirement may be relaxed in the future when Roact supports fragments . Methods \u00b6 connect \u00b6 Connects to the Rodux store attached to the Roact tree by StoreProvider , retrieving data from the store and optionally creating functions to dispatch actions. connect is a Higher-Order Component (HOC), which means that it wraps an existing component and adds additional functionality to it. Any props passed to the wrapped component will also be passed to the component that connect is wrapping. connect accepts two functions, both of which are optional: mapStateToProps , which accepts the store's state as the first argument, as well as the props passed to the component. mapStateToProps is run whenever the Rodux store updates, as well as whenever the props passed to your component are updated. mapDispatchToProps , which accepts a function that dispatches actions to your store. It works just like Store:dispatch in Rodux! mapDispatchToProps is only run once per component instance. Both mapStateToProps and mapDispatchToProps should return a table. These tables get merged into the props passed to the wrapped component. Info mapStateToProps can also return a function. When it does, the returned function will be used to retrieve state from the store on each update. This is usually used when working with memoized functions, similar to Redux's supplemental Reselect library. connect returns a function that should be called with the component to wrap. This API is sort of funky, but exists as-is for two primary reasons: Reusing the same connection for multiple components is useful, and can be used to create abstractions over connect . Since both mapStateToProps and mapDispatchToProps are optional, keeping them separate helps make the Roact-Rodux API cleaner. Base example: local function MyComponent ( props ) return Roact . createElement ( \"TextButton\" , { Text = props . value , [ Roact . Event . Activated ] = props . onClick , }) end MyComponent = RoactRodux . connect ( function ( state , props ) return { value = state . value , } end , function ( dispatch ) return { onClick = function () dispatch ({ type = \"increment\" , }) end , } end )( MyComponent ) Using the higher-order version of mapStateToProps : MyComponent = RoactRodux . connect ( function () local getValue = memoize ( function ( state ) return state . value end ) return function ( state , props ) return { value = getValue ( state ), } end end )( MyComponent ) The (very complicated) API signature of connect is: connect([mapStateToProps, [mapDispatchToProps]]) -> (componentToWrap) -> wrappedComponent where mapStateToProps: (storeState, props) -> propsToMerge OR () -> (storeState, props) -> propsToMerge mapDispatchToProps: (dispatchFn) -> propsToMerge","title":"API Reference"},{"location":"api-reference/#roact-components","text":"","title":"Roact Components"},{"location":"api-reference/#storeprovider","text":"StoreProvider accepts a Rodux store via the store prop and makes it available to all components rendered under it. It's possible to have multiple instances of StoreProvider in the same Roact tree, but most projects using Roact-Rodux will only have one. StoreProvider is generally at the top of the tree: Roact . createElement ( RoactRodux . StoreProvider , { store = someStore , }, { -- Any components created by `App` will be able to connect to someStore by -- using Roact-Rodux's `connect` method. App = Roact . createElement ( App ), }) Warning Due to limitations of Roact, StoreProvider can only have zero or one children. This requirement may be relaxed in the future when Roact supports fragments .","title":"StoreProvider"},{"location":"api-reference/#methods","text":"","title":"Methods"},{"location":"api-reference/#connect","text":"Connects to the Rodux store attached to the Roact tree by StoreProvider , retrieving data from the store and optionally creating functions to dispatch actions. connect is a Higher-Order Component (HOC), which means that it wraps an existing component and adds additional functionality to it. Any props passed to the wrapped component will also be passed to the component that connect is wrapping. connect accepts two functions, both of which are optional: mapStateToProps , which accepts the store's state as the first argument, as well as the props passed to the component. mapStateToProps is run whenever the Rodux store updates, as well as whenever the props passed to your component are updated. mapDispatchToProps , which accepts a function that dispatches actions to your store. It works just like Store:dispatch in Rodux! mapDispatchToProps is only run once per component instance. Both mapStateToProps and mapDispatchToProps should return a table. These tables get merged into the props passed to the wrapped component. Info mapStateToProps can also return a function. When it does, the returned function will be used to retrieve state from the store on each update. This is usually used when working with memoized functions, similar to Redux's supplemental Reselect library. connect returns a function that should be called with the component to wrap. This API is sort of funky, but exists as-is for two primary reasons: Reusing the same connection for multiple components is useful, and can be used to create abstractions over connect . Since both mapStateToProps and mapDispatchToProps are optional, keeping them separate helps make the Roact-Rodux API cleaner. Base example: local function MyComponent ( props ) return Roact . createElement ( \"TextButton\" , { Text = props . value , [ Roact . Event . Activated ] = props . onClick , }) end MyComponent = RoactRodux . connect ( function ( state , props ) return { value = state . value , } end , function ( dispatch ) return { onClick = function () dispatch ({ type = \"increment\" , }) end , } end )( MyComponent ) Using the higher-order version of mapStateToProps : MyComponent = RoactRodux . connect ( function () local getValue = memoize ( function ( state ) return state . value end ) return function ( state , props ) return { value = getValue ( state ), } end end )( MyComponent ) The (very complicated) API signature of connect is: connect([mapStateToProps, [mapDispatchToProps]]) -> (componentToWrap) -> wrappedComponent where mapStateToProps: (storeState, props) -> propsToMerge OR () -> (storeState, props) -> propsToMerge mapDispatchToProps: (dispatchFn) -> propsToMerge","title":"connect"},{"location":"guide/installation/","text":"First, install Roact and Rodux into the same place you intend to install Roact-Rodux. For these examples, we'll install everything into ReplicatedStorage . Method 1: Model File (Roblox Studio) \u00b6 Download the rbxmx model file attached to the latest release from the GitHub releases page Insert the model into Studio into a place like ReplicatedStorage Method 2: Rojo \u00b6 Copy the src directory into your codebase Rename the folder to RoactRodux Use Rojo to sync the files into a place","title":"Installation"},{"location":"guide/installation/#method-1-model-file-roblox-studio","text":"Download the rbxmx model file attached to the latest release from the GitHub releases page Insert the model into Studio into a place like ReplicatedStorage","title":"Method 1: Model File (Roblox Studio)"},{"location":"guide/installation/#method-2-rojo","text":"Copy the src directory into your codebase Rename the folder to RoactRodux Use Rojo to sync the files into a place","title":"Method 2: Rojo"},{"location":"guide/usage/","text":"Create a Store with Rodux \u00b6 Create your store as normal with Rodux : local function reducer ( state , action ) state = state or { value = 0 , } if action . type == \"increment\" then return { value = state . value + 1 , } end return state end local store = Rodux . Store . new ( reducer ) Add a StoreProvider \u00b6 When you render your Roact application, wrap the top-level component in a RoactRodux.StoreProvider : local app = Roact . createElement ( RoactRodux . StoreProvider , { store = store , }, { Main = Roact . createElement ( MyComponent ), }) This makes your Rodux store available for any components in your app. They'll access that store using the connect function. Connect with connect \u00b6 Use RoactRodux.connect to retrieve values from the store and use them in your Roact component: -- Write your component as if Rodux is not involved first. -- This helps guide you to create a more focused interface. local function MyComponent ( props ) -- Values from Rodux can be accessed just like regular props local value = props . value local onClick = props . onClick return Roact . createElement ( \"ScreenGui\" , nil , { Label = Roact . createElement ( \"TextButton\" , { -- ...and used in your components! Text = \"Current value: \" .. value , Size = UDim2 . new ( 1 , 0 , 1 , 0 ), [ Roact . Event . Activated ] = onClick , }) }) end -- `connect` accepts two optional functions: -- `mapStateToProps` accepts your store's state and returns props -- `mapDispatchToProps` accepts a dispatch function and returns props -- Both functions should return a table containing props that will be passed to -- your component! -- `connect` returns a function, so we call that function, passing in our -- component, getting back a new component! MyComponent = RoactRodux . connect ( function ( state , props ) -- mapStateToProps is run every time the store's state updates. -- It's also run whenever the component receives new props. return { value = state . value , } end , function ( dispatch ) -- mapDispatchToProps only runs once, so create functions here! return { onClick = function () dispatch ({ type = \"increment\" , }) end , } end )( MyComponent ) Now, whenever the store updates, your connected components will receive updated data and re-render! In many ways, Roact-Rodux works just like react-redux . The public API is almost identical and most of the best practices from that ecosystem work here as well.","title":"Using Roact-Rodux"},{"location":"guide/usage/#create-a-store-with-rodux","text":"Create your store as normal with Rodux : local function reducer ( state , action ) state = state or { value = 0 , } if action . type == \"increment\" then return { value = state . value + 1 , } end return state end local store = Rodux . Store . new ( reducer )","title":"Create a Store with Rodux"},{"location":"guide/usage/#add-a-storeprovider","text":"When you render your Roact application, wrap the top-level component in a RoactRodux.StoreProvider : local app = Roact . createElement ( RoactRodux . StoreProvider , { store = store , }, { Main = Roact . createElement ( MyComponent ), }) This makes your Rodux store available for any components in your app. They'll access that store using the connect function.","title":"Add a StoreProvider"},{"location":"guide/usage/#connect-with-connect","text":"Use RoactRodux.connect to retrieve values from the store and use them in your Roact component: -- Write your component as if Rodux is not involved first. -- This helps guide you to create a more focused interface. local function MyComponent ( props ) -- Values from Rodux can be accessed just like regular props local value = props . value local onClick = props . onClick return Roact . createElement ( \"ScreenGui\" , nil , { Label = Roact . createElement ( \"TextButton\" , { -- ...and used in your components! Text = \"Current value: \" .. value , Size = UDim2 . new ( 1 , 0 , 1 , 0 ), [ Roact . Event . Activated ] = onClick , }) }) end -- `connect` accepts two optional functions: -- `mapStateToProps` accepts your store's state and returns props -- `mapDispatchToProps` accepts a dispatch function and returns props -- Both functions should return a table containing props that will be passed to -- your component! -- `connect` returns a function, so we call that function, passing in our -- component, getting back a new component! MyComponent = RoactRodux . connect ( function ( state , props ) -- mapStateToProps is run every time the store's state updates. -- It's also run whenever the component receives new props. return { value = state . value , } end , function ( dispatch ) -- mapDispatchToProps only runs once, so create functions here! return { onClick = function () dispatch ({ type = \"increment\" , }) end , } end )( MyComponent ) Now, whenever the store updates, your connected components will receive updated data and re-render! In many ways, Roact-Rodux works just like react-redux . The public API is almost identical and most of the best practices from that ecosystem work here as well.","title":"Connect with connect"}]}